import "lib/std";
import "lib/io";
import "lib/json";
import "lib/os" as os;
import "lib/debug" as debug;

object LspState {
    | TODO: Maybe bad to keep this in memory
    {str, str} sources = <str, str>{},
    {str, Json} ast = <str, Json>{},
}

fun readContentLength() > num? {
    while (true) {
        str? header = stdin.readLine();

        if (header == null) {
            throw "Could not parse request header";
        }

        | Consume \r\n
        stdin.read(2);
        | Strip \r
        header = header!.sub(0, len: header!.len() - 1);
        const num? colon = header!.indexOf(": ");
        
        if (colon == null) {
            throw "Could not parse request header";
        }

        const str name = header!.sub(0, len: colon!);
        const str value = header!.sub(colon! + 2, len: null);
        
        if (name == "Content-Length") {
            return parseNumber(value);
        }
    }

    return null;
}

fun respond(str? strId, num? numId, Json result) > void {
    const Json response = Json{
        map = {
            "jsonrpc": Json{ string = "2.0" },
            "id": Json{ string = strId, number = numId },
            "result": result
        }
    };

    const str stringResponse = response.encode();

    stderr.write("Content-Length: {stringResponse.len()}\r\n\r\n{stringResponse}");
    stdout.write("Content-Length: {stringResponse.len()}\r\n\r\n{stringResponse}");
}

fun withinNode(Json node, str uri, num line, num column) > bool {
    const {str, Json} location = (node.mapValue()["location"] ?? Json{}).mapValue();
    const str script = location["script"]?.string ?? "*";
    const num startLine = location["start_line"]?.number ?? -1;
    const num endLine = location["end_line"]?.number ?? -1;
    const num startColumn = location["start_column"]?.number ?? -1;
    const num endColumn = location["end_column"]?.number ?? -1;

    | TODO: maybe put absolute path in location
    return uri.endsWith(script)
        and line >= startLine and line <= endLine
        and (endLine != startLine or (column >= startColumn and column <= endColumn));
}

fun findNodeUnder(Json root, str uri, num line, num column) > Json? {
    if (!withinNode(root, uri: uri, line: line, column: column)) {
        return null;
    }

    const str node = root.mapValue()["node"]?.string ?? "-";

    if (node == "Function") {
        const {str, Json} body = root.mapValue()["body"]!.mapValue();

        if (withinNode(root.mapValue()["body"]!, uri: uri, line: line, column: column)) {
            const [Json] statements = body["statements"]!.listValue();

            foreach (num i, Json statement in statements) {
                if (withinNode(statement, uri: uri, line: line, column: column)) {
                    return findNodeUnder(statement, uri: uri, line: line, column: column);
                }
            }
        }

        return node;
    } else if (node == "Enum") {
        const [Json] cases = root.mapValue()["cases"]!.listValue();

        foreach (num i, Json case in cases) {
            if (withinNode(case, uri: uri, line: line, column: column)) {
                return findNodeUnder(case, uri: uri, line: line, column: column);
            }
        }

        return node;
    } else if (node == "VarDeclaration") {
        const Json value = root.mapValue()["value"]!;

        if (withinNode(value, uri: uri, line: line, column: column)) {
            return findNodeUnder(value, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "FunDeclaration") {
        const Json function = root.mapValue()["function"]!;

        if (withinNode(function, uri: uri, line: line, column: column)) {
            return findNodeUnder(function, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "ObjectDeclaration") {
        const {str, Json} methods = root.mapValue()["methods"]!.mapValue();
        const {str, Json} members = root.mapValue()["members"]!.mapValue();

        foreach (str name, Json method in methods) {
            if (withinNode(method, uri: uri, line: line, column: column)) {
                return findNodeUnder(method, uri: uri, line: line, column: column);
            }   
        }

        foreach (str name, Json member in members) {
            if (withinNode(member, uri: uri, line: line, column: column)) {
                return findNodeUnder(member, uri: uri, line: line, column: column);
            }   
        }

        return node;
    } else if (node == "Binary") {
        const Json left = root.mapValue()["left"]!;
        const Json right = root.mapValue()["right"]!;

        if (withinNode(left, uri: uri, line: line, column: column)) {
            return findNodeUnder(left, uri: uri, line: line, column: column);
        }

        if (withinNode(right, uri: uri, line: line, column: column)) {
            return findNodeUnder(right, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Unary") {
        const Json left = root.mapValue()["left"]!;
        
        if (withinNode(left, uri: uri, line: line, column: column)) {
            return findNodeUnder(left, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Subscript") {
        const Json subscripted = root.mapValue()["subscripted"]!;
        const Json index = root.mapValue()["index"]!;
        const Json value = root.mapValue()["value"]!;

        if (withinNode(subscripted, uri: uri, line: line, column: column)) {
            return findNodeUnder(subscripted, uri: uri, line: line, column: column);
        }

        if (withinNode(index, uri: uri, line: line, column: column)) {
            return findNodeUnder(index, uri: uri, line: line, column: column);
        }

        if (withinNode(value, uri: uri, line: line, column: column)) {
            return findNodeUnder(value, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Unwrap") {
        const Json unwrapped = root.mapValue()["unwrapped"]!;

        if (withinNode(unwrapped, uri: uri, line: line, column: column)) {
            return findNodeUnder(unwrapped, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "ForceUnwrap") {
        const Json unwrapped = root.mapValue()["unwrapped"]!;

        if (withinNode(unwrapped, uri: uri, line: line, column: column)) {
            return findNodeUnder(unwrapped, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Is") {
        const Json left = root.mapValue()["left"]!;
        
        if (withinNode(left, uri: uri, line: line, column: column)) {
            return findNodeUnder(left, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Expression") {
        const Json expression = root.mapValue()["expression"]!;

        if (withinNode(expression, uri: uri, line: line, column: column)) {
            return findNodeUnder(expression, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "NamedVariable") {
        const Json value = root.mapValue()["value"]!;

        if (value.map != null and withinNode(value, uri: uri, line: line, column: column)) {
            return findNodeUnder(value, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Number") {
        return node;
    } else if (node == "String") {
        const [Json] elements = root.mapValue()["elements"]!;

        foreach (num i, Json element in elements) {
            if (withinNode(element, uri: uri, line: line, column: column)) {
                return findNodeUnder(element, uri: uri, line: line, column: column);
            }
        }

        return node;
    } else if (node == "StringLiteral") {
        return node;
    } else if (node == "Pattern") {
        return node;
    } else if (node == "Boolean") {
        return node;
    } else if (node == "Null") {
        return node;
    } else if (node == "List") {
        const [Json] items = root.mapValue()["items"]!;

        foreach (num i, Json item in items) {
            if (withinNode(item, uri: uri, line: line, column: column)) {
                return findNodeUnder(item, uri: uri, line: line, column: column);
            }
        }

        return node;
    } else if (node == "Map") {
        const {str, Json} map = root.mapValue()["items"]!.mapValue();

        foreach (str key, Json value in map) {
            if (withinNode(value, uri: uri, line: line, column: column)) {
                return findNodeUnder(value, uri: uri, line: line, column: column);
            }
        }

        return node;
    } else if (node == "Super") {
        const Json nthis = root.mapValue()["this"]!;
        const Json? nsuper = root.mapValue()["super"];
        const Json? call = root.mapValue()["call"];

        if (withinNode(nthis, uri: uri, line: line, column: column)) {
            return findNodeUnder(nthis, uri: uri, line: line, column: column);
        }

        if (nsuper != null and withinNode(nsuper, uri: uri, line: line, column: column)) {
            return findNodeUnder(nsuper, uri: uri, line: line, column: column);
        }

        if (call != null and withinNode(call, uri: uri, line: line, column: column)) {
            return findNodeUnder(call, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Dot") {
        const Json callee = root.mapValue()["callee"]!;
        const Json? value = root.mapValue()["value"];
        const Json? call = root.mapValue()["call"];

        if (withinNode(callee, uri: uri, line: line, column: column)) {
            return findNodeUnder(callee, uri: uri, line: line, column: column);
        }

        if (value != null and withinNode(value, uri: uri, line: line, column: column)) {
            return findNodeUnder(value, uri: uri, line: line, column: column);
        }

        if (call != null and withinNode(call, uri: uri, line: line, column: column)) {
            return findNodeUnder(call, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "ObjectInit") {
        const [Json] properties = root.mapValue()["properties"]!.listValue();
        
        foreach (num i, Json property in properties) {
            if (withinNode(property, uri: uri, line: line, column: column)) {
                return findNodeUnder(property, uri: uri, line: line, column: column);
            }
        }

        return node;
    } else if (node == "Throw") {
        const Json errorValue = root.mapValue()["error_value"]!;
        
        if (withinNode(errorValue, uri: uri, line: line, column: column)) {
            return findNodeUnder(errorValue, uri: uri, line: line, column: column);
        }

        return node;
    } else if (node == "Break") {
        return node;
    } else if (node == "Continue") {
        return node;
    } else if (node == "Call") {
        return node;
    } else if (node == "AsyncCall") {
        return node;
    } else if (node == "Resume") {
        return node;
    } else if (node == "Resolve") {
        return node;
    } else if (node == "Yield") {
        return node;
    } else if (node == "If") {
        return node;
    } else if (node == "Block") {
        return node;
    } else if (node == "Return") {
        return node;
    } else if (node == "For") {
        return node;
    } else if (node == "ForEach") {
        return node;
    } else if (node == "DoUntil") {
        return node;
    } else if (node == "While") {
        return node;
    } else if (node == "Export") {
        return node;
    } else if (node == "Import") {
        return node;
    } else if (node == "Catch") {
        return node;
    }
}

const {str, Function(LspState state, {str, Json} request) > Json} handlers = {
    "exit": fun (LspState state, {str, Json} request) > Json{
        os.exit(0);

        return Json{};
    },
    "initialize": fun (LspState state, {str, Json} request) > Json
        -> Json{
            map = {
                "capabilities": Json{
                    map = {
                        "declarationProvider": Json{ boolean = true },
                        "definitionProvider": Json{ boolean = true },
                    }
                },
                "serverInfo": Json{
                    map = {
                        "name": Json{ string = "buzz-lsp" },
                        "version": Json{ string= "0.0.1" },
                    },
                },
            },
        },
    "textDocument/definition": fun (LspState state, {str, Json} request) > Json {
        const {str, Json} textDocument = request["params"]?.mapValue()["textDocument"]?.mapValue() ?? <str, Json>{};
        str uri = textDocument["uri"]?.stringValue() ?? "";
        const {str, Json} position = textDocument["position"]?.mapValue() ?? <str, Json>{};
        const num line = position["line"]?.numberValue() ?? 0;
        const num column = position["column"]?.numberValue() ?? 0;

        if (!uri.startsWith("file://")) {
            stderr.write("Could not handle uri: {uri}\n");
            return Json{};    
        }

        | Dismiss "file://" prefix
        uri = uri.sub(7, len: null);

        str? source = state.sources[uri];
        if (source == null) {
            File file = File.open(uri, mode: FileMode.read);

            source = file.readAll();
            state.sources[uri] = source!;

            file.close();
        }

        Json ast = state.ast[uri] ?? Json.decode(debug.ast(source!, scriptName: uri));

        | Explore ast...
        stderr.write(ast.encode());

        | Skip entry point
        [Json] roots = ast.mapValue()["body"]?.mapValue()["statements"]?.list ?? <Json>[];
        foreach (num i, Json root in roots) {
            Json? node = findNodeUnder(ast, uri: uri, line: line, column: column);

            if (node != null) {

            }
        }

        return Json{};
    }
};

fun main([str] args) > void {
    LspState state = LspState{};

    while (true) {
        num? contentLength = readContentLength();

        if (contentLength == null or contentLength! <= 0) {
            throw "Request is empty";
        }

        str? requestRaw = stdin.read(contentLength ?? 0);

        stderr.write("Request is: `{requestRaw!}`\n");

        if (requestRaw == null) {
            throw "Could not read request";
        }

        {str, Json} request = Json.decode(requestRaw!).mapValue();
        const str? method = request["method"]?.string;

        stderr.write("Method is: `{method ?? "none"}`\n");

        Json result = Json{};
        if (method != null and handlers[method!] != null) {
            result = handlers[method!]!(state, request: request);
        }

        respond(
            strId: request["id"]?.string,
            numId: request["id"]?.number,
            result: result,
        );
    }
}