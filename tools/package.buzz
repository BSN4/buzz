import "lib/std";
import "lib/os" as os;
import "lib/fs" as fs;
import "lib/json";

enum PackageError {
    couldNotFetchPackage,
    couldNotParseDependency,
    couldNotParseVersion,
}

object Author {
    str name,
    str? url,
    str? email,

    static fun init(Json json) > Author !> JsonParseError {
        return Author{
            name = json.q(["name"]).stringValue(),
            url = json.q(["url"]).string,
            email = json.q(["email"]).string,
        };
    }
}

object SemVer {
    num major,
    num minor,
    num patch,

    static fun parse(str version) > SemVer !> PackageError {
        const pat versionPattern = _(\d+)\.(\d+)\.(\d+)_;

        if (versionPattern.match(version) -> versionMatch) {
            return SemVer{
                major = parseNumber(versionMatch[1]) ?? 0,
                minor = parseNumber(versionMatch[2]) ?? 0,
                patch = parseNumber(versionMatch[3]) ?? 0,
            };
        }

        throw PackageError.couldNotParseVersion;
    }

    fun toString() > str -> "{this.major}.{this.minor}.{this.patch}"
}

object Dependency {
    str packageName,
    str packagePublisher,
    SemVer version,
    SemVer maxVersion,
    Function() > void !> PackageError fetch,

    static fun parse(str name, str version) > Dependency !> PackageError {
        const pat namePattern = _([a-zA-Z0-9__-]+)/([a-zA-Z0-9__-]+)_;

        [str]? nameMatch = namePattern.match(name);

        if (nameMatch == null) {
            throw PackageError.couldNotParseDependency;
        }

        | TODO: ranges
        const SemVer ver = SemVer.parse(version);
        return Dependency{
            packagePublisher = nameMatch![1],
            packageName = nameMatch![2],
            version = ver,
            maxVersion = ver,
            fetch = gitHubFetch(user: nameMatch![1], repo: nameMatch![2], version: ver),
        };
    }
}

fun gitHubFetch(str user, str repo, SemVer version) > Function() > void !> PackageError !> PackageError {
    return gitFetch(
        publisher: user,
        name: repo,
        version: version,
        repository: "https://github.com/{user}/{repo}.git"
    );
}

fun gitFetch(str publisher, str name, SemVer version, str repository) > Function() > void !> PackageError {
    return fun () > void !> PackageError {
        try {
            fs.makeDirectory("vendor/{publisher}/{name}");

            num r = os.execute(["/usr/bin/env", "git", "clone", "--branch",  version.toString(), repository, "vendor/{publisher}/{name}"]);
            if (r != 0) {
                throw PackageError.couldNotFetchPackage;
            }

            fs.delete("vendor/{publisher}/{name}/.git");
        } catch {
            throw PackageError.couldNotFetchPackage;
        }
    };
}

| TODO: make it a builtin function of map and list
fun map(<T, R>, [T] source, Function(T element) > R transform) > [R] {
    [R] result = [<R>];

    foreach (num i, T element in source) {
        result.append(transform(element));
    }

    return result;
}

object Package {
    str name,
    str publisher,
    str? displayName,
    str description,
    [Author] authors,
    SemVer version,

    {str, Dependency} dependencies,
    {str, Dependency} devDependencies,

    static fun init(Json json) > Package !> PackageError, JsonParseError {
        return Package{
            name = json.q(["name"]).stringValue(),
            publisher = json.q(["publisher"]).stringValue(),
            displayName = json.q(["displayName"]).string,
            description = json.q(["description"]).stringValue(),
            authors = map(
                <Json, Author>,
                source: json.q(["authors"]).listValue(),
                transform: fun (Json author) > Author -> Author.init(author) catch Author{ name = "unknown" }
            ),
            version = SemVer.parse(json.q(["version"]).stringValue()),
        };
    }

    fun fetchDependencies() > void !> PackageError {
        foreach (str name, Dependency dep in this.dependencies) {
            dep.fetch();
        }
    }

    fun fetchDevDependencies() > void !> PackageError {
        foreach (str name, Dependency dep in this.devDependencies) {
            dep.fetch();
        }
    }
}