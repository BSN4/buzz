import "lib/std";
import "lib/os" as os;
import "lib/fs" as fs;
import "lib/json";
import "lib/io";

enum PackageError {
    couldNotFetchPackage,
    couldNotParseDependency,
    couldNotParseVersion,
}

object Author {
    str name,
    str? url = null,
    str? email = null,

    static fun fromJson(Json json) > Author !> JsonParseError {
        return Author{
            name = json.q(["name"]).stringValue(),
            url = json.q(["url"]).string,
            email = json.q(["email"]).string,
        };
    }
}

object SemVer {
    num major,
    num minor,
    num patch,

    static fun parse(str version) > SemVer !> PackageError {
        const pat versionPattern = _(\d+)\.(\d+)\.(\d+)_;

        if (versionPattern.match(version) -> versionMatch) {
            return SemVer{
                major = parseNumber(versionMatch[1]) ?? 0,
                minor = parseNumber(versionMatch[2]) ?? 0,
                patch = parseNumber(versionMatch[3]) ?? 0,
            };
        }

        throw PackageError.couldNotParseVersion;
    }

    fun toString() > str -> "{this.major}.{this.minor}.{this.patch}"
}

object Dependency {
    str packageName,
    str packagePublisher,
    SemVer version,
    SemVer maxVersion,
    Function() > void !> PackageError fetch,

    static fun parse(str name, str version) > Dependency !> PackageError {
        const pat namePattern = _([a-zA-Z0-9__-]+)/([a-zA-Z0-9__-]+)_;

        [str]? nameMatch = namePattern.match(name);

        if (nameMatch == null) {
            throw PackageError.couldNotParseDependency;
        }

        | TODO: ranges
        const SemVer ver = SemVer.parse(version);
        return Dependency{
            packagePublisher = nameMatch![1],
            packageName = nameMatch![2],
            version = ver,
            maxVersion = ver,
            fetch = gitHubFetch(user: nameMatch![1], repo: nameMatch![2], version: ver),
        };
    }
}

fun gitHubFetch(str user, str repo, SemVer version) > Function() > void !> PackageError !> PackageError {
    return gitFetch(
        publisher: user,
        name: repo,
        version: version,
        repository: "https://github.com/{user}/{repo}.git"
    );
}

fun gitFetch(str publisher, str name, SemVer version, str repository) > Function() > void !> PackageError {
    return fun () > void !> PackageError {
        try {
            fs.makeDirectory("vendor/{publisher}/{name}");

            num r = os.execute(["/usr/bin/env", "git", "clone", "--branch",  version.toString(), repository, "vendor/{publisher}/{name}"]);
            if (r != 0) {
                throw PackageError.couldNotFetchPackage;
            }

            fs.delete("vendor/{publisher}/{name}/.git");
        } catch {
            throw PackageError.couldNotFetchPackage;
        }
    };
}

| TODO: make it a builtin function of map and list
fun map(<T, R>, [T] source, Function(T element) > R transform) > [R] {
    [R] result = [<R>];

    foreach (num i, T element in source) {
        result.append(transform(element));
    }

    return result;
}

object Package {
    str name,
    str publisher,
    str? displayName,
    str description,
    [Author] authors = [<Author>],
    SemVer version,
    [str] targets = [<str>],

    {str, Dependency} dependencies = {<str, Dependency>},
    {str, Dependency} devDependencies = {<str, Dependency>},

    static fun fromJson(Json json) > Package !> PackageError, JsonParseError {
        return Package{
            name = json.q(["name"]).stringValue(),
            publisher = json.q(["publisher"]).stringValue(),
            displayName = json.q(["displayName"]).string,
            description = json.q(["description"]).stringValue(),
            authors = map(
                <Json, Author>,
                source: json.q(["authors"]).listValue(),
                transform: fun (Json author) > Author -> Author.fromJson(author) catch Author{ name = "unknown" }
            ),
            version = SemVer.parse(json.q(["version"]).stringValue()),
            targets = map(
                <Json, str>,
                source: json.q(["targets"]).listValue(),
                transform: fun (Json target) > str -> target.stringValue()
            )
        };
    }

    fun fetchDependencies() > void !> PackageError {
        foreach (str name, Dependency dep in this.dependencies) {
            dep.fetch();
        }
    }

    fun fetchDevDependencies() > void !> PackageError {
        foreach (str name, Dependency dep in this.devDependencies) {
            dep.fetch();
        }
    }
}

test "Test package" {
    try {
        File file = File.open("tools/buzz.json", mode: FileMode.read);

        str source = file.readAll();

        file.close();

        Package package = Package.fromJson(Json.decode(source));

        print(
            "name: {package.name}\n"
            + "publisher: {package.publisher}\n"
            + "description: {package.description}\n"
            + "version: {package.version.toString()}\n"
            + "authors: {package.authors.join(", ")}\n"
            + "targets: {package.targets.join(", ")}\n"
        );
    } catch (JsonParseError jsonError) {
        print(jsonError.message ?? "json error");
    }
}