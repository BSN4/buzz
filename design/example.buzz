| BASIC TYPES

str aString = "hello";     | A single line comment
num aNumber = 12;          | That way we can align them neatly
bool aBoolean = true;      | Only boolean can be used as conditions
str? aStringNullable;      | We have null-safety, default value is null
num? aNumNullable = null;  | null represents no-value
byte aByte = 0b10110110     | A byte
byte aByte = 0xFE
byte aByte = 234
type myType = str;         | Type are first-class 

| OPERATORS

| Arithmetic
12 + 12;
12 - 12;
12 * 12;
12 / 12;
12 % 12;
-12;

| Relational
a == b; | only allowed for variables of the same type, no coercion
a != b;
a > b;
a >= b;
a < b;
a <= b;
a ?? b; | if a is null then b
!a;

"abc" < "def";
1 < 3;
false < true;

| Logical
a and b;
a or b;
false and b; | -> b
a or false;  | -> a
!a;

| Bitwise (same as boolean operators but since operands are `byte`s the semantic is bitwise operations)
aByte and anotherByte;
aByte or anotherByte;
aByte xor anotherByte;
aByte >> anotherByte;
aByte << anotherByte;

| Concatenation
"hello" + " world";                                                   | -> "hello world"
[int][1, 2, 3] + [int][4, 5, 6];                                      | -> [1, 2, 3, 4, 5, 6]
{str, str}{ hello: "world", yo: "lo" } + {str, str}{ hello: "john" }; | -> { hello: "john", yo: "lo" }

| Interpolation
str name = "john";
print("hello {name} {12 + 5}"); | -> "hello john"

| Instance of
aString is str; | -> true

| Optional unwraping
[str]? yo = ["hello"];
yo!        | force unwrap (can we do without?)
yo?[0]     | graceful access
yo?.sort()
if (yo != null) {
    | yo is now promoted to a non-optional
}

| DATA STRUCTURES

[num] aList = [1, 2.12, 3]; | We can't have mixed content lists
aList[0];                   | -> 1 Lists act as expected
[str]["hello", "world"];    | List literal

{str, bool} aMap = {        | Map and Lists a basic types
    "hello": true,
    "world": false,
    strKey: true            | If keys are string, you can omit " if there's not whitespaces
};
{str, num}{"hello": 12};    | Map literal
aMap["hello"];              | Map access

| DECLARATION/ASSIGNMENT

str astring = "hello"; | basic declaration + assignment
str astring;           | Not allowed if not nullable, has to be initialized
aNum += 10;
aNum -= 10;
aNum *= 10;
aNum /= 10;
aNum++;
aNum--;
++aNum;
--aNum;
(aNum = 10) + 1; | Assignment returns the assigned value

| CONTROL STRUCTURES

if (expression) {
    | do something
} else if (expression) { | No need for a `else` keyword
    | do something
} else {
    | do something
}

while (expression) {
    | do something
}

do {

} until (expression)

for (num i = 0; i < 10; i++) {
    | do something
}

for (num element in list) {
    | do something
}

for (str key, num value in map) {
    | do something
}

switch (expression) {
    expressionA:
        statement;
        break;
    expressionB:
        statement;
        break;
    default:
        statement;
}

| FUNCTIONS

fun aFunction(str hello, num world, num? wat) > str {  | Basic function definition
}

(num age) -> age * 2; | Arrow function

(str name, num age) {     | Anonymous function
    print("{name} is {age} years old");

    return age * 2;
};

fun call(Function(str, num) > str fn) { | Function as first class objects
    fn("hello", 12);
}

call((str hello, num age) > str -> "{hello} i'm {age} years old");

aStr = aFunction(hello: "hi there", world: 1) | Function parameters are always named, order doesn't matter, optional can be omitted
aFunction("hi there")                         | Unless there's only one, then you can omit it
aFunction(hello: "hi there")                  | But naming it still works

| ENUMS

enum MyEnum {  | `enum MyEnum` == `enum num MyEnum`
    one,       | but values are assigned automatically starting from 0
    two,
    three
}

enum num MyEnum { | If you specify a type, you have to provide all values
    one = 1,
    two = 2,
    three = 3,
}

enum str MyEnum {
    hello = "cia",
    world = "mundo",
    name = "joe"
}

MyEnum.hello == "hello";

for (MyEnum value in MyEnum) {
    | Iterate over enum values
}

| CLASSES

| Simple inheritance, no notion of private/public (at least at first)

12.13.abs;               | Basic types are objects.
abs(12.13) == 12.13.abs; | Self-call Ã  la Lua but it works for everything

object MyObject { | A class that can't be inherited from (struct in C, struct in Swift)
    str name;     | Properties. You can't add any dynamically
    num? age;

    | An implicit constructor is provided with named parameters
    MyObject(str name, num? age); | Optional can be omited

    | Method
    fun sayHello() {
        print(hello);
    }
}

class MyClass { | Like `object` but can be extended
    str name;
}

class MyOtherClass < MyClass { | MyOtherClass inherits from MyClass
    fun printName() {
        print(this.name);
    }
}